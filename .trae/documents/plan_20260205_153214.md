He analizado tu solicitud y la arquitectura actual. Tienes toda la razón: para mantener la integridad del inventario, la columna `quantity` en la base de datos debe reflejar siempre la **unidad base**, mientras que guardamos los detalles de la conversión para la referencia visual.

Aquí está el plan de implementación:

### 1. Migración: Actualizar `productables`
Agregaremos las columnas necesarias para no perder el rastro de lo que el usuario eligió originalmente.
*   **Tabla**: `productables`
*   **Nuevas Columnas**:
    *   `unit_of_measure_id` (FK, nullable): La unidad que seleccionó el usuario.
    *   `quantity_uom` (decimal): La cantidad que ingresó el usuario (ej: 1).
    *   `uom_factor` (decimal): El factor de conversión usado en ese momento (ej: 12).

### 2. Request: Validar la Unidad
Actualizar `PurchaseRequest` para permitir y validar el nuevo campo.
*   `items.*.unit_of_measure_id`: Opcional (si es null, se asume unidad base), debe existir en `unit_of_measures`.

### 3. Controlador: La Lógica de Conversión
Modificar el método `store` y `update` en `PurchaseController` para implementar la "normalización" antes de guardar:

**Algoritmo Propuesto:**
1.  Recibir `quantity` (la del usuario, ej: 1) y `price` (precio por esa unidad, ej: 120).
2.  Buscar el `factor` de la unidad seleccionada (ej: 12). Si no hay unidad, factor = 1.
3.  Calcular **Valores Normalizados** (para la BD e Inventario):
    *   `quantity_real` = `quantity_usuario` * `factor` ( 1 * 12 = **12** ).
    *   `price_real` = `price_usuario` / `factor` ( 120 / 12 = **10** ).
4.  Guardar en `Productable`:
    *   `quantity`: 12 (Para que Kardex funcione directo).
    *   `price`: 10 (Costo unitario real).
    *   `subtotal`: 120 (Matemáticamente 12 * 10).
    *   `quantity_uom`: 1 (Para mostrar en el frontend).
    *   `uom_factor`: 12 (Para auditoría).

### 4. Modelo: Asignación Masiva
Actualizar `Productable` para permitir los nuevos campos en `$fillable` y definir la relación con `UnitOfMeasure`.

¿Te parece correcto este enfoque de "Normalizar al guardar"? Así el `KardexService` no necesita cambios y sigue operando con las cantidades reales.